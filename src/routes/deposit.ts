import { Router } from 'express';
import crypto from 'crypto';
import { db } from '../db/index.js';
import { settings, deposits, users, transactions } from '../db/schema.js';
import { eq, and } from 'drizzle-orm';
import { authMiddleware, AuthRequest } from '../middleware/auth.js';

const router = Router();

// Public endpoint - Get shop info (name, logo, banner) - no auth required
router.get('/shop-info', async (req, res) => {
    try {
        const shopName = await db.query.settings.findFirst({
            where: eq(settings.key, 'shop_name'),
        });
        const shopLogo = await db.query.settings.findFirst({
            where: eq(settings.key, 'shop_logo'),
        });
        const shopBanner = await db.query.settings.findFirst({
            where: eq(settings.key, 'shop_banner'),
        });

        res.json({
            shop_name: shopName?.value || 'AOV Shop',
            shop_logo: shopLogo?.value || '',
            shop_banner: shopBanner?.value || '',
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// Public endpoint - Get bank info for payment (no auth required)
router.get('/bank-info', async (req, res) => {
    try {
        const bankAccount = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_bank_account'),
        });
        const bankName = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_bank_name'),
        });
        const accountName = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_account_name'),
        });

        if (!bankAccount?.value) {
            return res.status(404).json({ message: 'Chưa cấu hình thông tin ngân hàng' });
        }

        res.json({
            sepay_bank_account: bankAccount.value,
            sepay_bank_name: bankName?.value || 'MB',
            sepay_account_name: accountName?.value || 'AOVSHOP',
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// Get SePay payment info for deposit
router.post('/create', authMiddleware, async (req: AuthRequest, res) => {
    try {
        const { amount } = req.body;

        if (!amount || amount < 10000) {
            return res.status(400).json({ message: 'Số tiền nạp tối thiểu 10,000đ' });
        }

        // Get SePay settings
        const merchantId = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_merchant_id'),
        });
        const bankAccount = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_bank_account'),
        });
        const bankName = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_bank_name'),
        });
        const accountName = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_account_name'),
        });


        if (!merchantId?.value || !bankAccount?.value) {
            return res.status(500).json({ message: 'Hệ thống thanh toán chưa được cấu hình' });
        }

        // Generate transfer content: NAP + DDMMYYHHMMSS + U + UserID
        const now = new Date();
        const pad = (n: number) => n.toString().padStart(2, '0');
        const timestamp = `${pad(now.getDate())}${pad(now.getMonth() + 1)}${now.getFullYear().toString().slice(-2)}${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        const transferContent = `NAP${timestamp}U${req.user!.id}`;

        // Create pending deposit (ID is auto-generated by database)
        const [deposit] = await db.insert(deposits).values({
            userId: req.user!.id,
            amount: parseFloat(amount),
            status: 'pending',
            reference: transferContent, // Store the transfer content as reference
        }).returning();

        // Return payment info (order_code = deposit.id)
        res.json({
            deposit,
            payment_info: {
                bank_name: bankName?.value || 'Ngân hàng',
                account_number: bankAccount.value,
                account_name: accountName?.value || 'AOV SHOP',
                amount: parseFloat(amount),
                order_code: deposit.id, // Auto ID from database
                content: transferContent,
                qr_url: `https://img.vietqr.io/image/${bankName?.value || 'MB'}-${bankAccount.value}-compact2.png?amount=${amount}&addInfo=${transferContent}&accountName=${encodeURIComponent(accountName?.value || 'AOVSHOP')}`,
            },
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// SePay Webhook - called when payment is confirmed
// Nội dung chuyển khoản = OrderCode_UserID (ví dụ: NAP123456_1)
router.post('/webhook', async (req, res) => {
    try {
        console.log('Webhook received:', JSON.stringify(req.body));

        // Get Secret Key from settings
        const secretKeySetting = await db.query.settings.findFirst({
            where: eq(settings.key, 'sepay_secret_key'),
        });

        // Verify Authorization header if Secret Key is configured
        if (secretKeySetting?.value) {
            const authHeader = req.headers['authorization'] || req.headers['Authorization'];
            const expectedAuth = `Apikey ${secretKeySetting.value}`;

            console.log('Auth header received:', authHeader);
            console.log('Expected auth:', expectedAuth);

            if (authHeader !== expectedAuth) {
                console.log('Invalid authorization - mismatch!');
                return res.status(401).json({ success: false, message: 'Unauthorized' });
            }
        }

        const {
            content,
            transferAmount,
            id: transactionId,
            gateway,
        } = req.body;

        if (!content || !transferAmount) {
            return res.json({ success: false, message: 'Missing content or amount' });
        }

        // Parse content format: NAP301224111342U1 (OrderCode U UserID)
        const match = content.match(/NAP(\d+)U(\d+)/i);
        if (!match) {
            console.log('Invalid content format:', content);
            return res.json({ success: false, message: 'Invalid content format' });
        }

        // Extract full content and user ID from format: NAP301224111342U1
        const transferContent = match[0]; // Full match: NAP301224111342U1
        const userId = parseInt(match[2]);
        console.log('Transfer content:', transferContent, 'User ID:', userId, 'Amount:', transferAmount);

        // Find pending deposit by reference (full transfer content)
        const deposit = await db.query.deposits.findFirst({
            where: and(eq(deposits.reference, transferContent), eq(deposits.status, 'pending')),
        });

        // Find user
        const user = await db.query.users.findFirst({
            where: eq(users.id, userId),
        });

        if (!user) {
            console.log('User not found:', userId);
            return res.json({ success: false, message: 'User not found' });
        }

        // Update user balance (ensure balance is a number, default to 0)
        const amount = parseFloat(transferAmount) || 0;
        const currentBalance = user.balance || 0;
        const newBalance = currentBalance + amount;

        if (amount <= 0) {
            console.log('Invalid amount:', transferAmount);
            return res.json({ success: false, message: 'Invalid amount' });
        }

        await db.update(users)
            .set({ balance: newBalance })
            .where(eq(users.id, user.id));

        // Update deposit status if found
        if (deposit) {
            await db.update(deposits)
                .set({ status: 'completed' })
                .where(eq(deposits.id, deposit.id));
        }

        // Create transaction record
        await db.insert(transactions).values({
            userId: user.id,
            type: 'deposit',
            amount: amount,
            balanceBefore: currentBalance,
            balanceAfter: newBalance,
            status: 'completed',
            description: `Nạp tiền tự động qua ${gateway || 'SePay'}`,
            reference: transactionId?.toString() || `SEPAY-${Date.now()}`,
        });

        console.log('Deposit completed for user:', userId, 'Amount:', amount, 'New balance:', newBalance);

        res.json({ success: true, userId, amount, newBalance });
    } catch (error) {
        console.error('Webhook error:', error);
        res.status(500).json({ success: false, message: 'Server error' });
    }
});

// Check deposit status
router.get('/status/:reference', authMiddleware, async (req: AuthRequest, res) => {
    try {
        const deposit = await db.query.deposits.findFirst({
            where: and(
                eq(deposits.reference, req.params.reference),
                eq(deposits.userId, req.user!.id)
            ),
        });

        if (!deposit) {
            return res.status(404).json({ message: 'Không tìm thấy giao dịch' });
        }

        res.json(deposit);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// Get deposit history
router.get('/history', authMiddleware, async (req: AuthRequest, res) => {
    try {
        const userDeposits = await db.query.deposits.findMany({
            where: eq(deposits.userId, req.user!.id),
            orderBy: (deposits, { desc }) => [desc(deposits.id)],
        });

        res.json(userDeposits);
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// Get user transactions (for frontend compatibility)
router.get('/transactions', authMiddleware, async (req: AuthRequest, res) => {
    try {
        const userTransactions = await db.query.transactions.findMany({
            where: eq(transactions.userId, req.user!.id),
            orderBy: (transactions, { desc }) => [desc(transactions.id)],
        });

        res.json({ data: userTransactions });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

// Get balance
router.get('/balance', authMiddleware, async (req: AuthRequest, res) => {
    try {
        const user = await db.query.users.findFirst({
            where: eq(users.id, req.user!.id),
        });

        res.json({ balance: user?.balance || 0 });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Lỗi server' });
    }
});

export default router;
